
# Setup
 This section will guide you how to setup this project

1. Create empty folder structure as on photo 
    ![Folder structure](./Assets/FolderStructure.png "Project folder structure")
2. Init WebAPI project from tempalte using command  `dotnet new WebAPI` inside `src/WebAPI/API/` folder. This will scaffold default `.net WebAPI` template including basic setup that we donÂ´t need to write manualy like `appsettings.json`, `Startup.cs`, `Program.cs`, `Properties/launchSettings.json` and `API.csproj`...
3. Remove content of `Controllers` folder and remove `WeatherForecast.cs` from main folder. This was generated by template and is not needed for demo.

## Lunch  WebAPI project
 
Current setup contains empty WebAPI program. There are several ways to run it.

- By running `dotnet run` or `dotnet watch run` from `src/WebAPI/API/` folder using command line (terminal).
    -  `watch` means that process will watch your file changes and in case you edit any files, process will automaticaly restart server. This is helpfull in development so you dont need to do it manualy after new changes in code.

- Using your editor VsCode or VsStudio or any other...
    - Note that VSCode use different lunch settings if you run app using its debugger attached. (More in section [Enviroment](#enviroment).

# Understanding init setup

 This section explain what was created by `dotnet new WebAPI` scaffolding. It is good to understand what is preconfigured.

## AppBuilder

In `Program.cs` the [Default builder](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/DefaultBuilder/src/WebHost.cs#L156) is used by template to configure your app.

```c#
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder => {
            webBuilder.UseStartup<Startup>();
        });
```

**This happends under the hood:**

1) Enviroment - Default `HostBuilder` is created. It includes code defaults enviroment settings. 
2) Configuration from `appsettings.json` and `appsettings.{enviroment}.json` is loaded and applyed.
3) Loads Enviroment variables (for concrete Enviroment)
4) Configure Logging (Some default preconfigured)
5) Adds service provider - [Dependency injection](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/Hosting/Hosting/src/GenericHost/GenericWebHostBuilder.cs#L201)  (more about DI under [oficial Docs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0)).

This is part of `.NetCore` default app init process. It will preconfigure typical settings for aplication. This configuration can be overridden in code or custom builder with own configuration steps can be injected. You can read more under official [Microsoft Docs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-5.0#default).

Configuration is done by calling multiple [providers](https://docs.microsoft.com/en-us/dotnet/core/extensions/configuration-providers). This providers reads key-value pairs using a variety of sources:

- Settings files, as `appsettings.json` (JSON/XML/INI)
- Environment variables as `ASPNETCORE_ENVIRONMENT`
- Azure Key Vault / Azure App Configuration
- Command-line arguments
- Custom providers, installed or created
- Directory files
- In-memory objects

This is JSON file example, containing Logging configuration as key-value paris. This can be loaded using `.AddJsonFile(...)` during app start.

```Json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
    }
  },
}
```
Why we have so many providers options? 
- Sometimes in dev. we wanna just simply loads all variables from one file. And we wanna simply switch between different enviroments.
- In big distributed systems we wanna have centralised storage for multiple services.
- For secreats we require som process to handle ussage of this variables to keep content protected. As example this can be done using Azure secrets storage where protected value is written to enviroment variables by Azure process where the secreat is stored in time app is deployed.
- Testing reasons and enviroment etc..

## Enviroment

`.NetCore` configures app behavior based on the runtime environment using an environment variable.

The `IHostingEnvironment` allows you to programatically set the current environment to have environment-specific behaviour.

This is done by default builder:

>`CreateDefaultBuilder` creates [WebHostBuilder](https://github.com/dotnet/aspnetcore/blob/d8bba727bdfaa3abf196c7f7c476966ed4af6692/src/DefaultBuilder/src/WebHost.cs#L156) object.
> 
>>  ```c#
>>   public static IWebHostBuilder CreateDefaultBuilder(string[] args){
>>      var builder = new WebHostBuilder(); // <--- This
>>      // etc...
>>  ```
> By initializing object [new WebHostBuilder()](https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/WebHostBuilder.cs) 
> 
>> ```c#
>>  public WebHostBuilder(){
>>      _hostingEnvironment = new HostingEnvironment(); // <--- This
>>      // etc...
>>  ```
>
>1) The private `new HostingEnvironment()` object [is created](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/Hosting/Hosting/src/Internal/HostingEnvironment.cs#L9). It holds builder `EnvironmentName`. By default it is `Production`. **This is code default** value and depending on start and other configuration can be overwritten on startup to other values as for example `development`.
>>```c#
>>internal class HostingEnvironment : IHostingEnvironment, Extensions.Hosting.IHostingEnvironment, IWebHostEnvironment{
>>      public string EnvironmentName { get; set; } = Extensions.Hosting.Environments.Production; // <--- This
>>      // etc...
>>```
>2) Default enviroment variables with prefix `ASPNETCORE_` are [loaded to configuration](https://github.com/dotnet/aspnetcore/blob/e6afd501caf0fc5d64b6f3fd47584af6f7adba43/src/Hosting/Hosting/src/WebHostBuilder.cs#L45) if they exist.
>>```c#
>>_config = new ConfigurationBuilder()
>>    .AddEnvironmentVariables(prefix: "ASPNETCORE_") // <--- This
>>    .Build();
>>```
>-  If `eviroment` variable exist settings overide code defaults..

Enviroment can be set from various sources:
- Reads directly from system enviroment variable `ASPNETCORE_ENVIRONMENT` if exist.
- Looks if any start `args` was privided and if contains specific Key, it override value from system environment (`ASPNETCORE_ENVIRONMENT`)
- `launchSettings.json` is used in case section (key) `environmentVariables` was povided, then it override value from system environment (`ASPNETCORE_ENVIRONMENT`).
- Code default - if no other source was found (`Production`)

`launchSettings.json` is used by default by VisualStudio, Rider or by running your app from command line using `dotnet cli` etc.. Some editors create custom lunch files like VSCode (when you wanna  run app using its debugger). It will create custom `launch.json` under folder `.vscode`. It does similar think. You can find more info in [VsCode Docs](https://code.visualstudio.com/docs/editor/debugging).

The `launchSettings.json`
- Is only used on development
- Is not deployed.

#### Current enviroment

When you run app with logging enabled, you will see in one of the first logs the current enviroment name.

```Shell
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: https://localhost:5001
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
```

> **WARNING**: The app's environment can't be changed while the app is running.

In runtime you can use `IWebHostEnvironment` to get DI enviroment provider object. By including extension `using Microsoft.Extensions.Hosting;` in your namespace definition , you can easy conditionaly check for enviroment value in rutime.

```c#
// env as IWebHostEnvironment injected by DI
if (env.IsDevelopment()){ ... }
else if(env.IsProduction){ ... }
else if(env.IsStaging){ ... }
```

## AppSettings

`appsettings.json` and `appsettings.development.json` was generated by template and provides settings that aplication loads by [default](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/DefaultBuilder/src/WebHost.cs#L173).
>
>```c#
>config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
>    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true, reloadOnChange: true);
>```

The `appsettings.json` cover basic shared settings `appsettings.development.json` can contains developer enviroment specific settings like different connection strings or some settings / variables.

`reloadOnChange:true` means, app watches the file changes and in case of any updates, the configuration is reloaded without need to restart the server.

Generated `appsettings.json` and `appsettings.development.json` contains default logging configuration. And CORS AllowedHost variable.

`*` means server accept request from any origin. This value can be overwrite in custom configuration which will be laiter introduced.

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

You can run app and change log Level from `"Microsoft": "Warning",` to `"Microsoft": "Information"`. Since both  `appsettings.json` and `appsettings.development.json` contains logging configuration first the value is taken from  `appsettings.json`  and than `appsettings.development.json` override it. So depending on your current enviroment the value is applyed in runtime. If you are in `development` you need to change it in `appsettings.development.json`. Note that If you delet entire loging configuration from `appsettings.development.json`  then the value from `appsettings.json` will be used since it will be not overided anymore.

> **INFO**: Settings files are used in same time just in case they have equal propertis inside it, this propertis gets override by each other in app configuration.

## Startup.cs

This class is used by `ConfigureWebHostDefaults` from `Program.cs` on app init and contains 2 methods:
1) `ConfigureServices` - IoC (DI) container servcie registration (call order does not metter)

    ```c#
    public void ConfigureServices(IServiceCollection services) {
        //services.AddControllers();
        services.AddSwaggerGen(c => {
            c.SwaggerDoc("v1", new OpenApiInfo { Title = "API", Version = "v1" });
        });
    }
    ```
2) `Configure` - Http Request pipeline setup (call order metters) This is how your request goes through app.

    ```c#
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env) {
        // Order of call sets request pipe order !
        if (env.IsDevelopment()) {
            app.UseDeveloperExceptionPage();
            app.UseSwagger();
            app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "API v1"));
        }
        app.UseHttpsRedirection();
        app.UseRouting();
        app.UseAuthorization();
        app.UseEndpoints(endpoints => {
            endpoints.MapControllers();
        });
    }
    ```

You can read about app `Startup.cs` more [under oficial doc](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-5.0).

## ConfigureServices 

The ConfigureServices method:

- Is Optional.
- Called by the host before the `Configure` method to register all DI services.

By default it register OpenAPI (Swagger) service. (Expecting the app was ceated from API tempale)

```
services.AddSwaggerGen(c => {
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "API", Version = "v1" });
});
```

`ConfigureServices` can have a lot of lines of code in real aplication. The good is to remember everitime when it has more than 3 lines or the registration is context related (Authorization, Fileserver etc..) and group that to separate extension for `IServiceCollection`.

As example lets show more complex swagger configiration. With that the `Program.cs` can get big and hard to read. In this example it is better to move this swagger related stuff to separate extension that allow us to just call `services.AddSwagger()` and all details will be hidden in separate file.

```
public static partial class ServiceExtension {
    public static IServiceCollection AddSwagger(
        this IServiceCollection serviceCollection) {
        serviceCollection.AddSwaggerGen(
            e => {

                e.SwaggerDoc("v1", new OpenApiInfo { Title = "My API", Version = "v1" });
                e.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme {
                    Description = "JWT Authorization header is using the Bearer scheme. \r\n\r\n Example: \"Bearer {key}\"",
                    Name = "Authorization",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.ApiKey,
                    Scheme = "Bearer"
                });
                e.AddSecurityRequirement(new OpenApiSecurityRequirement()
                {
                {
                    new OpenApiSecurityScheme
                    {
                        Reference = new OpenApiReference
                        {
                            Type = ReferenceType.SecurityScheme,
                            Id = "Bearer"
                        },
                        Scheme = "oauth2",
                        Name = "Bearer",
                        In = ParameterLocation.Header,

                    },
                    new List<string>()
                }
            });
            });

        return serviceCollection;
    }
}
```

#### Swagger

[Swagger](swagger.io) is opensource framework used to make design, implementation and documentation of API much simpler. The specification itself is called [OpenAPI](https://swagger.io/docs/specification/about/) (previously Swagger Specification) it is Interface Description Language for describing RESTful APIs.

**Helps with:**
- Developing - Automatic generation of OpenAPI.
- Documenting - Self documenting. Can use comments from code and merge it with generated documenation based on your code.
- Interaction - Swagger UI provides easy way to test your API.
- Tooling - Swager editor, Swagger generator

> **INFO**: An OpenAPI file allows you to describe your entire API include:
>- Available endpoints (/users) and operations on each endpoint (GET /users, POST /users)
>- Operation parameters Input and output for each operation
>- Authentication methods
>- Contact information, license, terms of use and other information..

This generated file usualy served as JSON is laiter loaded by SwaggerUI which transform this specification to human interactiv API documenattion.

If two companies works on som interface between thier systems, both can use OpenAPi to describe each side interface. Today moder code-geerators are able to fully generate client based on this specification.

This demo will use swagger to test some fuctionality.

## Configure (Middleware)

Middleware is code that's added in pipeline to handle requests and responses. The function call order is important since it sets the request order over system.

```
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) {
    if (env.IsDevelopment()) {
        app.UseDeveloperExceptionPage();
        app.UseSwagger();
        app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "API v1"));
    }
    app.UseHttpsRedirection();
    app.UseRouting();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =>{
        endpoints.MapControllers();
    });
}
```

Each Middleware:

- Chooses whether to pass the request to the next middleware in pipeline.
- Can perform work before and after the next component in the pipeline.

Using this you can inject custom code on any position in request or response and return for example error in case request contains some value or exception happend on response.

![Pipeline example](./Assets/DefaultPipeline.png "Pipeline example")

As it is displayed on drawing (and code) some middlewares are applyed conditionaly only on `development` enviroment.

`app.UseDeveloperExceptionPage()` Adds middleware enabling web-server to show exception detail in case of error. By default this is disabled from security reasons. Imagine this as function wrapping code to `try{}catch{}` and in case of exception it returns simple html with exception message. This is what this middleware do.
`app.UseSwagger()` Adds middleware allowing us to access and download generated OpenAPI on specific URL. This is part of Swagger Library.
`app.UseSwaggerUI(...) `Adds middleware allowing us to browse and test generated API documentation. Its running under specific url.
`UseHttpsRedirection()` - Foce server to use HTTPS and autoredirect from HTTP protocol.
`UseRouting))` - Adds route matching to the middleware pipeline. This middleware looks at the set of endpoints defined in the app, and selects the best match based on the request. (Matches request to an endpoint)
`UseEndpoints(...)` - Adds endpoint execution to the middleware pipeline. It runs the delegate associated with the selected endpoint. (Execute the matched endpoint)

**Impornatnt notes:**

- If the app calls `UseStaticFiles`, place `UseStaticFiles` before UseRouting.
- t's important that you place the `Authentication` and `Authorization` middleware between UseRouting and UseEndPoints .
- Any middleware that appears after the `UseRouting()` call will know which endpoint will run eventually. Any middleware that appears before the `UseRouting()` call won't know which endpoint will run eventually.

## API.csproj

This is project configuration file. It tells .NET how to build the project. It contains project, language, compiler and tooling settings. The content can change between different language versions.

```
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="5.6.3" />
  </ItemGroup>
</Project>
```

To understand detail you can [read oficial docs](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/deployment/web-deployment-in-the-enterprise/understanding-the-project-file).







